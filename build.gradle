apply plugin: 'java'
apply plugin: 'signing'
apply plugin: 'maven'

group = "com.dorr.persistent"
version = '0.1.0'
ext.source_version = "git rev-parse HEAD".execute().text
ext.can_sign = project.hasProperty("signing.keyId")

// build
compileJava {
    sourceCompatibility = 1.6
    targetCompatibility = 1.6
}
tasks.withType(JavaCompile) {
    // apply this to main & test compilation
    options.compilerArgs << "-Xlint:unchecked"
}
jar {
    manifest {
        attributes("Specification-Title": "Persistent data structures",
                   "Specification-Vendor": "Douglas Orr",
                   "Specification-Version": version,
                   "Implementation-Title": "com.dorr.persistent",
                   "Implementation-Version": source_version)
    }
}
javadoc {
    options.addStringOption("link", "http://docs.oracle.com/javase/7/docs/api")
}

task sourcesJar(type: Jar) {
    from sourceSets.main.allSource
    classifier = 'sources'
}
task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from 'build/docs/javadoc'
}

// signing & publishing
artifacts {
    archives jar
    archives javadocJar
    archives sourcesJar
}
signing {
    required { can_sign }
    sign configurations.archives
}
uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

            if (project.hasProperty("sonatypeUsername")) {
                repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
                    authentication(userName: "$sonatypeUsername", password: "$sonatypePassword")
                }
            }
            pom.project {
                name 'Persistent'
                packaging 'jar'
                description 'A very small persistent data structures library for use in plain old Java'
                url 'http://douglasorr.github.io/Persistent/'

                scm {
                    url 'scm:git@github.com:DouglasOrr/Persistent.git'
                    connection 'scm:git@github.com:DouglasOrr/Persistent.git'
                    developerConnection 'scm:git@github.com:DouglasOrr/Persistent.git'
                }
                licenses {
                    license {
                        name 'MIT License'
                        url 'http://opensource.org/licenses/MIT'
                    }
                }
                developers {
                    developer {
                        id 'douglasorr'
                        name 'Douglas Orr'
                    }
                }
            }
        }
    }
}

// deps
repositories {
    mavenCentral()
}
dependencies {
    testCompile 'junit:junit:4.11'
    testCompile 'org.hamcrest:hamcrest-all:1.3'
    testCompile 'org.clojure:clojure:1.6.0'
    testCompile 'org.scala-lang:scala-library:2.11.4'

    testCompile 'com.google.guava:guava:18.0'
    testCompile files('lib/object-explorer.jar')
}

// other tasks
task runPerformance(dependsOn: 'testClasses', type: JavaExec, description: "Run the performance tests (slow)") {
    main = 'com.dorr.persistent.Comparisons$Performance'
    classpath = sourceSets.test.runtimeClasspath
}

task runMemory(dependsOn: 'testClasses', type: JavaExec, description: "Run the memory size tests") {
    main = 'com.dorr.persistent.Comparisons$Memory'
    classpath = sourceSets.test.runtimeClasspath
    jvmArgs = ['-javaagent:lib/object-explorer.jar']
}

task publishDoc(dependsOn: 'javadoc') << {
    def remote = "git@github.com:DouglasOrr/Persistent.git"
    def pages = "build/gh-pages"
    def docs = "doc/${version}"
    def javadoc = new File("build/docs/javadoc")

    // refresh the pages clone
    ["rm -rf ${pages}",
     "git clone --single-branch --branch gh-pages ${remote} ${pages}"].each {
        it.execute().waitFor()
    }
    // copy in, commit, push docs
    ["rm -rf ${docs}",
     "cp -r ${javadoc.getAbsolutePath()} ${docs}",
     "git add --all ${docs}",
     ["git", "commit", "--message", "Update docs for ${version} (${source_version.substring(0,8)})"],
     "git push"
    ].each {
        def proc = it.execute(null, new File(pages))
        proc.waitFor()
        if (proc.exitValue() != 0) {
            throw new GradleScriptException("\$ ${it} failed with code ${proc.exitValue()}, saying:\n${proc.err.text}", null)
        }
    }
}
// TODO - generate & publish performance reports

task release(dependsOn: ['uploadSnapshots', 'publishDoc'])
